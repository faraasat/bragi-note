generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum Tier {
  FREE
  PRO
  TEAM
  ENTERPRISE
}

enum Feature {
  CATCH_UP
  REWRITE
  EXPLAIN
}

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String?
  image         String?
  emailVerified DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Subscription
  tier          Tier      @default(FREE)
  stripeCustomerId       String?   @unique
  stripeSubscriptionId   String?   @unique
  stripePriceId          String?
  stripeCurrentPeriodEnd DateTime?

  // Usage tracking
  usageQuotas   UsageQuota[]

  // User preferences
  preferences   UserPreferences?

  // AI interactions
  catchUpSessions    CatchUpSession[]
  rewriteSessions    RewriteSession[]
  explainSessions    ExplainSession[]

  // Authentication
  accounts      Account[]
  sessions      Session[]
}

model UserPreferences {
  id                String   @id @default(cuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Communication preferences
  defaultTone       String?  @default("professional")
  communicationStyle String?

  // AI preferences
  preferredModel    String?
  enableLearning    Boolean  @default(true)
  privacyMode       Boolean  @default(false)

  // Notification preferences
  emailNotifications Boolean  @default(true)
  extensionNotifications Boolean @default(true)

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model UsageQuota {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  feature     Feature
  count       Int      @default(0)
  periodStart DateTime @default(now())
  periodEnd   DateTime

  @@unique([userId, feature, periodStart])
}

model CatchUpSession {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  source      String   // "slack", "teams", "email", etc.
  inputType   String   // "transcript", "chat_export", "email_thread"

  // Content (encrypted for privacy)
  inputText   String
  summary     Json     // Structured summary output

  // Metadata
  detectedActions Int  @default(0)
  detectedDeadlines Int @default(0)
  processingTimeMs Int

  createdAt   DateTime @default(now())
}

model RewriteSession {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  originalText String
  intent       String  // "de-escalate", "professional", etc.
  rewrittenText String

  // User feedback
  wasUsed      Boolean @default(false)
  feedbackRating Int?  // 1-5

  createdAt   DateTime @default(now())
}

model ExplainSession {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  inputText   String
  category    String?  // "medical", "legal", "financial", "technical"

  // Multi-layer output
  tldr        String
  clearExplanation String
  detailedAnalysis String

  // User feedback
  wasHelpful  Boolean @default(false)

  createdAt   DateTime @default(now())
}

// NextAuth models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
